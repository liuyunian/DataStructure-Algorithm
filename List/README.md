# 线性表
## 定义
0个或多个数据元素的有限序列  
理解：相同类型的元素之间是有顺序的，第一个元素只有一个后继节点，没有前驱节点，最后一个元素只有一个前驱节点，没有后继节点，其他元素各有一个前驱节点和后继节点

## 抽象数据类型
```
ADT 线性表（List）
Data //数据元素
    数据元素之间满足线性表的定义
Operation //操作数据的方法
    InitList(*L)            //初始化操作，建立一个空的线性表
    ListEmpty(L)            //若线性表为空，返回true，否则返回false
    ClearList(*L)           //将线性表清空
    GetElem(L, i, *e)       //将线性表L中的第i个元素值返回给e
    LocateElem(L, e)        //在线性表L中查找与给定值e相等的元素，如果成功，返回该元素在表中的序号，否则返回0
    ListInsert(*L, i ,e)    //在线性表L中第i个位置插入新元素e
    ListDelete(*L, i, e)    //删除线性表L中第i个位置元素，并用e返回其值
    ListLength(L)           //返回线性表L的元素个数
endADT
```

## 具体实现
从存储结构上分，线性表的实现可以分成两种：  
* 顺序存储结构：动态数组
* 链式存储结构：单链表、双向链表、循环链表

### [动态数组(Deque)](Deque.h)
C/C++中只提供的静态数组（不考虑STL），静态数组的优点是随机访问，存取元素的时间复杂度是O(1)，缺点是容量固定，往往会造成内存浪费
动态数组可以根据数组存储元素的多少，动态调整容量

### [单链表(ForwardList)](ForwardList.h)
每个节点有一个数据域（存储数据）和一个指针域（指向后继节点），最后一个节点的指针域指向nullptr  
使用头指针操作链表，遍历链表只能从头指针开始，所以访问链表中第一个节点的时间复杂度为O(1)，访问最后一个节点的时间复杂度为O(N)  

核心函数如下：  

| 函数 | 功能 | 时间复杂度 |
| --- | :---: | :---: |
| push_front | 向链表头部添加元素 | O(1) |
| pop_front | 移除链表头部的元素 | O(1) |
| push_back | 向链表尾部添加元素 | O(N) |
| pop_back | 移除链表尾部的元素 | O(N) |

单链表操作尾部的元素需要从头部遍历到尾部之后才能操作，所以时间复杂度为O(N)  
当然可以维护一个尾指针指向最后一个结点，但是这相当于空间换时间

### [循环链表(CircleList)](CircleList.h)
循环链表的每个节点也是有一个数据域和一个指针域构成，与单链表不同的是链表最后一个节点的指针域指向第一个节点，这样链表就围成了一个环  
循环链表的好处是：从链表中的任意一个节点开始都能遍历完整个链表  
循环链表中使用尾指针来操作循环链表，这样访问最后一个节点和第一个节点的时间复杂度就都是O(1)

核心函数如下：

| 函数 | 功能 | 时间复杂度 |
| --- | :---: | :---: |
| push_front | 向链表头部添加元素 | O(1) |
| pop_front | 移除链表头部的元素 | O(1) |
| push_back | 向链表尾部添加元素 | O(1) |
| pop_back | 移除链表尾部的元素 | O(N) |

由于pop_back()需要找到最后一个节点的前驱节点，所以需要遍历整个链表，时间复杂度为O(N)

### [双向链表(List)](List.h)
双向链表每个节点是由一个数据域和两个指针域（分别指向前驱节点和后继节点）构成  
优点在于可以正向或者反向遍历链表，灵活性提高  
缺点是每个节点多了一个指针域，多占用了存储空间（32位4字节，64位8字节）
一般情况下，双向链表都会以双向循环链表方式实现，这样可以优势最大化

核心函数如下：

| 函数 | 功能 | 时间复杂度 |
| --- | :---: | :---: |
| push_front | 向链表头部添加元素 | O(1) |
| pop_front | 移除链表头部的元素 | O(1) |
| push_back | 向链表尾部添加元素 | O(1) |
| pop_back | 移除链表尾部的元素 | O(1) |